"pesquisa",
label = "Survey",
choices = NULL,
options = list(placeholder = "All surveys")
),
shiny::textInput(
"busca",
label = "Search aggregate name",
placeholder = "e.g. IPCA, abate, PIB..."
),
shiny::actionButton(
"clear_filters",
"Clear all filters",
class = "btn-sm btn-outline-secondary w-100"
),
shiny::hr(),
shiny::markdown(
"Use the filters above or the column filters in the table header."
)
),
# ── Main panel ──
bslib::layout_column_wrap(
width = 1/3,
bslib::value_box(
title = "Aggregates",
value = shiny::textOutput("n_aggregates", inline = TRUE),
showcase = bsicons::bs_icon("table"),
theme = "primary"
),
bslib::value_box(
title = "Surveys",
value = shiny::textOutput("n_surveys", inline = TRUE),
showcase = bsicons::bs_icon("clipboard-data"),
theme = "info"
),
bslib::value_box(
title = "Showing",
value = shiny::textOutput("n_filtered", inline = TRUE),
showcase = bsicons::bs_icon("funnel"),
theme = "dark"
)
),
bslib::card(
bslib::card_header(
class = "d-flex justify-content-between align-items-center",
shiny::tagList(
shiny::strong("Aggregate catalog"),
shiny::tags$span(
class = "text-muted small ms-2",
"(click a row to copy the aggregate ID)"
)
),
shiny::downloadButton("download_csv", "CSV", class = "btn-sm btn-outline-primary")
),
DT::DTOutput("tabela"),
full_screen = TRUE
)
)
# ── Server ────────────────────────────────────────────────────────────────
server <- function(input, output, session) {
# Load data once
dataset <- shiny::reactive({
shiny::withProgress(message = "Fetching aggregates from IBGE...", {
ibger::ibge_aggregates()
})
})
# Populate survey dropdown after data loads
shiny::observe({
df <- dataset()
nomes <- sort(unique(df$survey_name))
shiny::updateSelectizeInput(
session, "pesquisa",
choices = c("All surveys" = "", nomes),
server = TRUE
)
})
# Filtered data
df_filtrado <- shiny::reactive({
df <- dataset()
if (!is.null(input$pesquisa) && nzchar(input$pesquisa)) {
df <- df[df$survey_name == input$pesquisa, ]
}
if (nzchar(input$busca)) {
df <- df[grepl(input$busca, df$aggregate_name, ignore.case = TRUE), ]
}
df
})
# Value boxes
output$n_aggregates <- shiny::renderText(nrow(dataset()))
output$n_surveys    <- shiny::renderText(length(unique(dataset()$survey_name)))
output$n_filtered   <- shiny::renderText(nrow(df_filtrado()))
# Table
output$tabela <- DT::renderDT({
DT::datatable(
df_filtrado(),
elementId = "tabela",
colnames = c(
"Survey ID"      = "survey_id",
"Survey"         = "survey_name",
"Aggregate ID"   = "aggregate_id",
"Aggregate name" = "aggregate_name"
),
selection = "single",
filter = "top",
rownames = FALSE,
class = "compact stripe hover w-100",
options = list(
# autoWidth=FALSE helps DT respond better to container resizes
autoWidth = FALSE,
columnDefs = list(
list(className = 'dt-center', targets = 0:2),
list(className = 'dt-left', targets = 3)
),
pageLength = 25,
scrollX = TRUE,
deferRender = TRUE,
# 'p' is pagination; ensure it exists and sits close to the table
dom = "<'dt-top d-flex justify-content-between align-items-center'ip>t<'dt-bottom d-flex justify-content-between align-items-center'ip>",
# adjust columns right after init (important in RStudio Viewer)
initComplete = DT::JS("function(settings, json) { var api = this.api(); setTimeout(function(){ api.columns.adjust(); }, 60); }"),
language = list(
info = "Showing _START_ to _END_ of _TOTAL_ aggregates",
infoFiltered = "(filtered from _MAX_)",
infoEmpty = "No aggregates found",
zeroRecords = "No aggregates match the current filters"
)
)
)
}, server = TRUE)
# When data changes (filtering), ask DT to re-adjust widths
shiny::observeEvent(df_filtrado(), {
session$sendCustomMessage("ibger_dt_adjust", list(id = "tabela"))
}, ignoreInit = TRUE)
# Clear all filters (sidebar + table header filters)
shiny::observeEvent(input$clear_filters, {
# Sidebar inputs
shiny::updateSelectizeInput(session, "pesquisa", selected = "")
shiny::updateTextInput(session, "busca", value = "")
# Reset paging + selection (nice UX)
proxy <- DT::dataTableProxy("tabela")
DT::selectRows(proxy, NULL)
DT::replaceData(proxy, df_filtrado(), resetPaging = TRUE, clearSelection = "all")
# Clear DT search + column filters + header inputs via JS
session$sendCustomMessage("ibger_dt_clear", list(id = "tabela"))
session$sendCustomMessage("ibger_dt_adjust", list(id = "tabela"))
}, ignoreInit = TRUE)
# Copy aggregate ID on row click
shiny::observeEvent(input$tabela_rows_selected, {
row <- df_filtrado()[input$tabela_rows_selected, ]
if (nrow(row) < 1) return()
id <- row$aggregate_id
name <- row$aggregate_name
shiny::showNotification(
shiny::tagList(
shiny::tags$b(paste0("Aggregate ", id)),
shiny::br(),
name,
shiny::br(),
shiny::tags$code(paste0("ibge_metadata(", id, ")"))
),
type = "message",
duration = 6
)
})
# CSV download
output$download_csv <- shiny::downloadHandler(
filename = function() paste0("ibge_aggregates_", Sys.Date(), ".csv"),
content  = function(file) utils::write.csv(df_filtrado(), file, row.names = FALSE)
)
}
shiny::shinyApp(ui, server)
## ibger Aggregate Explorer
## Launched via ibge_explorer()
# ── UI ─────────────────────────────────────────────────────────────────────
require(htmltools)
require(bsicons)
require(shiny)
require(DT)
require(utils)
ui <- bslib::page_sidebar(
title = "ibger",
theme = bslib::bs_theme(
version = 5,
preset = "shiny",
primary = "#0d3b66",
"navbar-bg" = "#0d3b66",
base_font = bslib::font_google("Jost"),
heading_font = bslib::font_google("Jost"),
font_scale = 0.9
),
shiny::tags$head(
shiny::tags$style(
htmltools::HTML("
/* Overall font sizing */
body { font-size: 0.92rem; }
/* Make DT table body slightly smaller than the rest of the app */
.dataTables_wrapper table.dataTable { font-size: 0.82rem; }
/* Header filters (filter='top') */
.dataTables_wrapper thead input {
font-size: 0.78rem;
padding: 2px 6px;
height: 28px;
}
/* Tighten spacing so pagination hugs the table */
.dataTables_wrapper .dt-top,
.dataTables_wrapper .dt-bottom {
padding: 6px 10px;
margin: 0;
}
.dataTables_wrapper .dataTables_info,
.dataTables_wrapper .dataTables_paginate {
margin: 0;
}
/* Keep the card from creating its own scroll */
.bslib-card .card-body { overflow: visible; }
")
)
),
# ── Sidebar ──
sidebar = bslib::sidebar(
width = 320,
title = "Filters",
shiny::selectizeInput(
"pesquisa",
label = "Survey",
choices = NULL,
options = list(placeholder = "All surveys")
),
shiny::textInput(
"busca",
label = "Search aggregate name",
placeholder = "e.g. IPCA, abate, PIB..."
),
shiny::actionButton(
"clear_filters",
"Clear all filters",
class = "btn-sm btn-secondary w-100"
),
shiny::hr(),
shiny::markdown(
"Use the filters above or the column search in the table.
Click any row to copy the aggregate ID."
)
),
# ── Main panel ──
bslib::layout_columns(
col_widths = c(4, 4, 4),
bslib::value_box(
title = "Aggregates",
value = shiny::textOutput("n_aggregates", inline = TRUE),
#showcase = bsicons::bs_icon("table"),
theme = "primary"
),
bslib::value_box(
title = "Surveys",
value = shiny::textOutput("n_surveys", inline = TRUE),
#showcase = bsicons::bs_icon("clipboard-data"),
theme = "info"
),
bslib::value_box(
title = "Showing",
value = shiny::textOutput("n_filtered", inline = TRUE),
#showcase = bsicons::bs_icon("funnel"),
theme = "dark"
)
),
bslib::card(
bslib::card_header(
class = "d-flex justify-content-between align-items-center",
"Aggregate catalog",
shiny::downloadButton("download_csv", "CSV", class = "btn-sm btn-outline-primary")
),
bslib::card_body(
padding = 0,
DT::DTOutput("tabela")
),
full_screen = TRUE
)
)
# ── Server ─────────────────────────────────────────────────────────────────
server <- function(input, output, session) {
# Load data once
dataset <- shiny::reactive({
shiny::withProgress(message = "Fetching aggregates from IBGE...", {
ibger::ibge_aggregates()
})
})
# Populate survey dropdown after data loads
shiny::observe({
df <- dataset()
nomes <- sort(unique(df$survey_name))
shiny::updateSelectizeInput(
session, "pesquisa",
choices = c("All surveys" = "", nomes),
server = TRUE
)
})
# Filtered data
df_filtrado <- shiny::reactive({
df <- dataset()
if (!is.null(input$pesquisa) && nzchar(input$pesquisa)) {
df <- df[df$survey_name == input$pesquisa, ]
}
if (nzchar(input$busca)) {
pattern <- input$busca
df <- df[grepl(pattern, df$aggregate_name, ignore.case = TRUE), ]
}
df
})
# Value boxes
output$n_aggregates <- shiny::renderText(nrow(dataset()))
output$n_surveys    <- shiny::renderText(length(unique(dataset()$survey_name)))
output$n_filtered   <- shiny::renderText(nrow(df_filtrado()))
# Table
output$tabela <- DT::renderDT({
DT::datatable(
df_filtrado(),
colnames = c(
"Survey ID"      = "survey_id",
"Survey"         = "survey_name",
"Aggregate ID"   = "aggregate_id",
"Aggregate name" = "aggregate_name"
),
selection = "single",
filter = "top",
rownames = FALSE,
class = "compact stripe hover",
options = list(
autoWidth = TRUE, # Important for columnDefs width to work consistently
columnDefs = list(
list(className = 'dt-center', targets = 0:2), # Center align first three columns
list(className = 'dt-left', targets = 3)   # Right align the remaining columns
),
pageLength = 25,
scrollX = TRUE,
deferRender = TRUE,
dom = "<'dt-top d-flex justify-content-between align-items-center'ip>t<'dt-bottom d-flex justify-content-between align-items-center'ip>",
language = list(
info = "Showing _START_ to _END_ of _TOTAL_ aggregates",
infoFiltered = "(filtered from _MAX_)",
infoEmpty = "No aggregates found",
zeroRecords = "No aggregates match the current filters"
)
)
)
})
# Clear all filters (sidebar + table header filters)
shiny::observeEvent(input$clear_filters, {
# Sidebar inputs
shiny::updateSelectizeInput(session, "pesquisa", selected = "")
shiny::updateTextInput(session, "busca", value = "")
# DT filters (global + per-column + header inputs from filter='top')
proxy <- DT::dataTableProxy("tabela")
# Replace data (keeps table in sync and resets paging)
DT::clearSearch(proxy)
#DT::replaceData(proxy, df_filtrado(), resetPaging = TRUE, clearSelection = "all")
})
# Copy aggregate ID on row click
shiny::observeEvent(input$tabela_rows_selected, {
row <- df_filtrado()[input$tabela_rows_selected, ]
id <- row$aggregate_id
name <- row$aggregate_name
shiny::showNotification(
shiny::tagList(
shiny::tags$b(paste0("Aggregate ", id)),
shiny::br(),
name,
shiny::br(),
shiny::tags$code(paste0('ibge_metadata(', id, ')'))
),
type = "message",
duration = 6
)
})
# CSV download
output$download_csv <- shiny::downloadHandler(
filename = function() {
paste0("ibge_aggregates_", Sys.Date(), ".csv")
},
content = function(file) {
utils::write.csv(df_filtrado(), file, row.names = FALSE)
}
)
}
shiny::shinyApp(ui, server)
pkgdown::build_site()
setwd("~/Github/ibger")
pkgdown::build_site()
pkgdown::build_site()
devtools::submit_cran()
library(ibger)
library(dplyr)
library(tidyr)
library(ggplot2)
library(lubridate)
library(stringr)
# Monthly periods: "202501" -> 2025-01-01
period_to_monthly <- function(x) ym(x)
# Quarterly periods: "202501" -> 2025-01-01
# lubridate::yq() expects "2025.1", so we reformat first
period_to_quarterly <- function(x) {
yr <- substr(x, 1, 4)
qt <- as.integer(substr(x, 5, 6))
as.Date(paste0(yr, "-", qt * 3 - 2, "-01"))
}
meta_7060 <- ibge_metadata(7060)
meta_7060
tidyr::unnest(meta$classifications, categories)
tidyr::unnest(meta_7060$classifications, categories)
meta_7060
meta_7060$id
meta_7060$name
meta_7060$classifications
tidyr::unnest(meta_7060$classifications, categories)
tidyr::unnest(meta_7060$classifications, categories) %>% filter(category_id %in% c("7169", "7695"))
ipca_health <- ibge_variables(
aggregate = 7060,
variable = 63,                          # IPCA - Monthly variation
periods = -12,
classification = list(
"315" = "7695"             # General index + Health insurance
),
localities = "N7[2601]"                 # Recife Metropolitan Area
) |>
mutate(
value  = parse_ibge_value(value),
period = period_to_monthly(period)
) |>
select(period, classification_315, locality_name, value)
ipca_health
ibge_localities(7060, level = N6)
ibge_localities(7060, level = "N6")
ibge_localities(7060, level = "N7")
meta_7060
tidyr::unnest(meta_7060$classifications, categories) %>% filter(category_id %in% c("7643"))
tidyr::unnest(meta_7060$classifications, categories) %>% filter(category_id %in% c("7169"))
meta_8693 <- ibge_metadata(8693)
# Browse classifications and categories
unnest(meta_8693$classifications, categories)
meta_8693$variables
meta_8693
ibge_variables(
aggregate = 8693,
variable = 7167,                          # Index number (2022 = 100)
periods = -12,
classification = list(
"11046" = "all",                        # All index types (revenue + volume)
"12355" = "106876"                      # Transportation/postal services
),
localities = "N3[26]"                     # Pernambuco
)
meta_8693
tidyr::unnest(meta_8693$classifications, categories)
meta_5434 <- ibge_metadata(5434)
meta_5434
ibge_variables(8884, periods = "202101-202304", localities = "BR")
ibge_variables(8884, periods = "202101-", localities = "BR")
ibge_variables(8884, periods = "-4", localities = "BR")
ibge_variables(8884, periods = "-40", localities = "BR")
pnad_accommodation <- ibge_variables(
aggregate = 5434,
variable = 4090,                          # Employed persons (thousands)
periods = -4,                            # Last 12 quarters
classification = list("888" = "56623"),   # Accommodation and food services
localities = "N3[26]"                     # Pernambuco
) |>
mutate(
value  = parse_ibge_value(value),
period = period_to_quarterly(period)
) |>
select(period, classification_888, locality_name, value)
pnad_accommodation
meta_5434
tidyr::unnest(meta_5434$classifications, categories) %>% filter(category_id %in% c("56623"))
meta_8693 <- ibge_metadata(8693)
meta_8693
agrs <- ibge_aggregates()
View(agrs)
meta <- ibge_metadata(1549)
meta
ibge_metadata(1547)
ibge_metadata(3331)
ibge_metadata(3544)
ibge_metadata(3987)
ibge_metadata(10049)
ibge_metadata(10057)
meta_8693
tidyr::unnest(meta_5434$classifications, categories) %>% filter(category_id %in% c("56628"))
meta_8888 <- ibge_metadata(8888)
meta_8888
remotes::install_github("StrategicProjects/ibger")
meta_8888
meta$periodicity
meta_7060$periodicity
meta_8693$periodicity
meta_5434$periodicity
meta_8888$periodicity
meta_8888
agrs <- ibge_aggregates()
agrs <- ibge_aggregates()
meta_8888
tidyr::unnest(meta_8888$classifications, categories)
tidyr::unnest(meta_8888$classifications, categories) %>% print(n = 100)
tidyr::unnest(meta_8888$classifications, categories) %>% filter(category_id %in% c("129332"))
tidyr::unnest(meta_8888$classifications, categories) %>% filter(category_id %in% c("129332")) %>% select(category_id, category_name)
meta_8888 <- ibge_metadata(8884)
meta_8884 <- ibge_metadata(8884)
meta_8884
meta_8757 <- ibge_metadata(8757)
meta_8757
meta_8880 <- ibge_metadata(8880)
meta_8880
